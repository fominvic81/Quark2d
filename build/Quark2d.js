!function(t){var e={};function s(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return t[i].call(o.exports,o,o.exports,s),o.l=!0,o.exports}s.m=t,s.c=e,s.d=function(t,e,i){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},s.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)s.d(i,o,function(e){return t[e]}.bind(null,o));return i},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=0)}([function(t,e,s){"use strict";s.r(e),s.d(e,"Quark2d",(function(){return lt}));class i{constructor(){this.events=new Map}on(t,e){this.events.get(t)||this.events.set(t,[]),this.events.get(t).push(e)}trigger(t,e=[]){const s=this.events.get(t);if(s)for(const t of s)t(...e)}}const o={IDs:{},sign:t=>t>=0?1:-1,nextId:(t="id")=>(void 0===o.IDs[t]&&(o.IDs[t]=-1),++o.IDs[t],o.IDs[t]),combineId:(t,e)=>t<e?"A"+t+"B"+e:"A"+e+"B"+t,clamp:(t,e,s)=>e>t?e:s<t?s:t,contains:(t,e,s)=>!(e>t||s<t)};class n{constructor(){this.id=o.nextId(),this.name="composite",this.bodies=new Map,this.constraints=new Map,this.composites=new Map,this.events=new i}add(t){Array.isArray(t)||(t=[t]);for(const e of t)switch(e.name){case"body":this.addBody(e);break;case"constraint":this.addConstraint(e);break;case"composite":this.addComposite(e)}}addBody(t){Array.isArray(t)||(t=[t]);for(const e of t)this.events.trigger("beforeAdd",[{object:e}]),this.bodies.set(e.id,e),this.events.trigger("afterAdd",[{object:e}])}removeBody(t,e=!1){Array.isArray(t)||(t=[t]);let s=[this],i=t.length;for(;s.length>0;){const o=s.pop();for(const e of t)o.bodies.has(e.id)&&(this.events.trigger("beforeRemove",[{object:e}]),o.bodies.delete(e.id),this.events.trigger("afterRemove",[{object:e}]),--i);if(i<=0&&!e)break;for(const t of o.composites.values())s.push(t)}}allBodies(){let t=[...this.bodies.values()];for(const e of this.composites.values())t=t.concat(e.allBodies());return t}addConstraint(t){Array.isArray(t)||(t=[t]);for(const e of t)this.events.trigger("beforeAdd",[{object:e}]),this.constraints.set(e.id,e),this.events.trigger("afterAdd",[{object:e}])}removeConstraint(t,e=!1){Array.isArray(t)||(t=[t]);let s=[this],i=t.length;for(;s.length>0;){const o=s.pop();for(const e of t)o.constraints.has(e.id)&&(this.events.trigger("beforeRemove",[{object:e}]),o.constraints.delete(e.id),this.events.trigger("afterRemove",[{object:e}]),--i);if(i<=0&&!e)break;for(const t of o.composites.values())s.push(t)}}allConstraints(){let t=[...this.constraints.values()];for(const e of this.composites.values())t=t.concat(e.allConstraints());return t}addComposite(t){Array.isArray(t)||(t=[t]);for(const e of t)this.events.trigger("beforeAdd",[{object:e}]),this.composites.set(e.id,e),this.events.trigger("afterAdd",[{object:e}])}removeComposite(t){Array.isArray(t)||(t=[t]);for(const e of t)this.events.trigger("beforeRemove",[{object:e}]),this.composites.delete(e.id),this.events.trigger("afterRemove",[{object:e}])}}class r{constructor(t=0,e=0){this.x=t,this.y=e}static clone(t,e){return e?(e.x=t.x,e.y=t.y,e):new r(t.x,t.y)}static set(t,e,s){return t.x=e,t.y=s,t}static rotate(t,e,s=t){const i=Math.cos(e),o=Math.sin(e),n=t.x,r=t.y;return s.x=n*i-r*o,s.y=n*o+r*i,s}static length(t){return Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2))}static lengthSquared(t){return Math.pow(t.x,2)+Math.pow(t.y,2)}static normalise(t,e=t){const s=r.length(t);return e.x=t.x/s,e.y=t.y/s,e}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}static add(t,e,s=t){return s.x=t.x+e.x,s.y=t.y+e.y,s}static subtract(t,e,s=t){return s.x=t.x-e.x,s.y=t.y-e.y,s}static scale(t,e,s=t){return s.x=t.x*e,s.y=t.y*e,s}static divide(t,e,s=t){return s.x=t.x/e,s.y=t.y/e,s}static neg(t,e=t){return e.x=-t.x,e.y=-t.y,e}static rotate90(t,e=t){const s=t.x;return e.x=-t.y,e.y=s,e}static isCollinear(t,e){return Math.abs(t.x/t.y-e.x/e.y)<1e-4||0===t.y&&0===e.y}static rayRayIntersectionPoint(t,e,s,i,o=new r){const n=e.y-t.y,a=t.x-e.x,h=n*t.x+a*t.y,c=i.y-s.y,l=s.x-i.x,d=c*s.x+l*s.y,p=n*l-c*a;return 0===p?void 0:(r.set(o,(l*h-a*d)/p,(n*d-c*h)/p),o)}static getSide(t,e){const s=r.cross(t,e);return s>.001?1:s<-.001?-1:0}static lineLineIntersection(t,e,s,i){const o=r.subtract(e,t,r.temp[0]),n=r.subtract(s,t,r.temp[1]),a=r.subtract(i,t,r.temp[2]);return r.getSide(o,n)!==r.getSide(o,a)&&(r.subtract(i,s,o),r.subtract(t,s,n),r.subtract(e,s,a),r.getSide(o,n)!==r.getSide(o,a))}}r.temp=[new r,new r,new r,new r,new r,new r,new r],r.zero=new r(0,0);class a{constructor(t){this.engine=t,this.world=t.world,this.pairs=new Map,this.activePairsCount=0}update(){this.activePairsCount=0}}class h{constructor(t,e){this.bodyA=t,this.bodyB=e,this.id=o.combineId(this.bodyA.id,this.bodyB.id),this.shapePairs=new Map,this.isActive=!1,this.isSleeping=!1,this.contacts=[],this.prev={isActive:!1,isSleeping:!1}}reset(){this.contacts.length=0}updatePrev(){this.prev.isActive=this.isActive,this.prev.isSleeping=this.isSleeping}}class c{constructor(){this.vertex=new r,this.normalImpulse=0}}class l{constructor(t,e){this.shapeA=t,this.shapeB=e,this.id=o.combineId(this.shapeA.id,this.shapeB.id),this.isActive=!1,this.depth=0,this.separation=0,this.normal=new r,this.tangent=new r,this.penetration=new r,this.contactsCount=0,this.contacts=[new c,new c],this.prev={isActive:!1,normal:new r,tangent:new r,penetration:new r,depth:0}}update(){r.scale(this.normal,this.depth,this.penetration),r.rotate90(this.normal,this.tangent),this.friction=Math.min(this.shapeA.friction,this.shapeB.friction),this.frictionStatic=Math.min(this.shapeA.frictionStatic,this.shapeB.frictionStatic),this.restitution=Math.max(this.shapeA.restitution,this.shapeB.restitution)}updatePrev(){this.prev.isActive=this.isActive,this.prev.depth=this.depth,r.clone(this.normal,this.prev.normal),r.clone(this.tangent,this.prev.tangent),r.clone(this.penetration,this.prev.penetration)}}class d{constructor(){this.map=new Map}get(t){return this.map.get(this.getId(t))}set(t,e){return this.map.set(this.getId(t),e)}delete(t){this.map.delete(this.getId(t))}getId(t){return t.x+"o"+t.y}getPositionById(t){const[e,s]=t.split("o").map(t=>Number(t));return new r(e,s)}clear(){this.map.clear()}keys(){const t=[];for(const e of this.map.keys())t.push(this.getPositionById(e));return t}values(){return[...this.map.values()]}entries(){const t=[];for(const e of this.map.keys())t.push([this.getPositionById(e),this.map.get(e)]);return t}}class p{constructor(){this.min=new r,this.max=new r}clone(t){return t||(t=new p),t.min.x=this.min.x,t.min.y=this.min.y,t.max.x=this.max.x,t.max.y=this.max.y,t}fromVertices(t){this.min.x=1/0,this.min.y=1/0,this.max.x=-1/0,this.max.y=-1/0;for(const e of t)e.x>this.max.x&&(this.max.x=e.x),e.x<this.min.x&&(this.min.x=e.x),e.y>this.max.y&&(this.max.y=e.y),e.y<this.min.y&&(this.min.y=e.y);return this}set(t,e){this.min=t,this.max=e}translate(t){r.add(this.min,t),r.add(this.max,t)}contains(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}overlaps(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.max.y>=t.min.y&&this.min.y<=t.max.y}getWidth(){return this.max.x-this.min.x}getHeight(){return this.max.y-this.min.y}static combine(t,e){if(0!==t.length){e||(e=new p),e.min.x=1/0,e.min.y=1/0,e.max.x=-1/0,e.max.y=-1/0;for(const s of t)e.min.x=Math.min(e.min.x,s.min.x),e.min.y=Math.min(e.min.y,s.min.y),e.max.x=Math.max(e.max.x,s.max.x),e.max.y=Math.max(e.max.y,s.max.y);return e}}}p.temp=[new p];class u{constructor(t){this.engine=t,this.type=u.BODY_SLEEPING}update(t){const e=this.engine.world.allBodies();for(const s of e)s.isStatic&&s.sleepState===u.SLEEPING||(0===s.force.x&&0===s.force.y?s.sleepState!=u.SLEEPING&&(s.motion=.8*(r.lengthSquared(s.velocity)+Math.pow(s.angularVelocity,2)/4)+.2*s.motion,s.motion<=u.MOTION_SLEEP_LIMIT?s.sleepyTimer+=t:s.sleepyTimer>0&&(s.sleepyTimer-=t),s.sleepyTimer>=u.SLEEPY_TIME_LIMIT&&s.setSleeping(u.SLEEPING)):s.setSleeping(u.AWAKE))}afterCollisions(){const t=this.engine.narrowphase.activePairs;for(const e of t){if(e.bodyA.sleepState!==u.SLEEPING&&e.bodyB.sleepState!==u.SLEEPING)continue;const t=e.bodyA.sleepState===u.SLEEPING,s=t?e.bodyA:e.bodyB;s.isStatic||(t?e.bodyB:e.bodyA).motion>u.COLLISION_MOTION_SLEEP_LIMIT&&s.setSleeping(u.AWAKE)}const e=this.engine.narrowphase.endedPairs;for(const t of e)t.bodyA.isStatic||t.bodyA.setSleeping(u.AWAKE),t.bodyB.isStatic||t.bodyB.setSleeping(u.AWAKE);const s=this.engine.narrowphase.startedPairs;for(const t of s)t.bodyA.isStatic||t.bodyA.setSleeping(u.AWAKE),t.bodyB.isStatic||t.bodyB.setSleeping(u.AWAKE)}}u.AWAKE=0,u.SLEEPING=1,u.READY_FALL_ASLEEP=2,u.MOTION_SLEEP_LIMIT=18e-6,u.COLLISION_MOTION_SLEEP_LIMIT=4e-5,u.SLEEPY_TIME_LIMIT=1,u.BODY_SLEEPING=0,u.ISLAND_SLEEPING=1;class m extends a{constructor(t){super(t),this.grid=new d,this.gridSize=1}update(){super.update();for(const t of this.pairs.values()){const e=t.bodyA.sleepState===u.SLEEPING&&t.bodyB.sleepState===u.SLEEPING;if(t.isSleeping&&e)t.prev.isSleeping=!0;else{t.updatePrev(),t.isActive=!1,t.isSleeping=e;for(const e of t.shapePairs.values())e.updatePrev(),e.isActive=!1}}const t=this.engine.world.allBodies();for(const e of t)for(const t of e.shapes){const e=this.createRegion(t.getBounds(),p.temp[0]);t.region&&t.region.id===e.id||(this.updateRegion(e,e,t),t.region&&this.updateRegion(t.region,e,t),t.region||(t.region=this.createRegion(t.getBounds(),new p)),e.clone(t.region),t.region.id=e.id)}for(const t of this.grid.values()){const e=[...t.values()];if(t.render=!1,!(e.length<2))for(let s=0;s<e.length;++s)for(let i=s+1;i<e.length;++i){const n=e[s].body,r=e[s],a=e[i].body,c=e[i];if(n===a)continue;if(n.isStatic&&a.isStatic)continue;const d=o.combineId(n.id,a.id),p=this.pairs.get(d),u=p||new h(n,a);if(p||this.pairs.set(d,u),!u.isSleeping||!u.prev.isSleeping){u.isActive=!0;const t=o.combineId(r.id,c.id),e=u.shapePairs.get(t),s=e||new l(r,c);s.isActive=!0,e||u.shapePairs.set(t,s)}this.activePairsCount+=1,t.render=!0}}return this.pairs}createRegion(t,e){return r.divide(t.min,this.gridSize,e.min),r.divide(t.max,this.gridSize,e.max),e.min.x=Math.floor(e.min.x),e.min.y=Math.floor(e.min.y),e.max.x=Math.floor(e.max.x),e.max.y=Math.floor(e.max.y),e.id=this.regionId(e),e}regionId(t){return t.min.x+"|"+t.min.y+"|"+t.max.x+"|"+t.max.y}combineRegions(t,e,s){return r.set(s.min,Math.min(t.min.x,e.min.x),Math.min(t.min.y,e.min.y)),r.set(s.max,Math.max(t.max.x,e.max.x),Math.max(t.max.y,e.max.y)),s.id=this.regionId(s),s}createCell(t){const e=new Map;return this.grid.set(t,e),e}addShapeToCell(t,e){const s=this.grid.get(t);s?s.set(e.id,e):this.createCell(t).set(e.id,e)}removeShapeFromCell(t,e){const s=this.grid.get(t);s&&(s.delete(e.id),0===s.size&&this.grid.delete(t))}updateRegion(t,e,s){for(let i=t.min.x;i<=t.max.x;++i)for(let o=t.min.y;o<=t.max.y;++o){const t=r.set(r.temp[2],i,o);if(!s.region){this.addShapeToCell(t,s);continue}const n=s.region.contains(t),a=e.contains(t);!a||n?a||!n||this.removeShapeFromCell(t,s):this.addShapeToCell(t,s)}}removeShapeFromGrid(t){if(t&&t.region)for(let e=t.region.min.x;e<=t.region.max.x;++e)for(let s=t.region.min.y;s<=t.region.max.y;++s){const i=r.set(r.temp[2],e,s);this.removeShapeFromCell(i,t)}}removeBodyFromGrid(t){for(const e of t.shapes)this.removeShapeFromGrid(e)}}class g{constructor(t=4294967295,e=1,s=0){this.mask=t,this.category=e,this.group=s}static canCollide(t,e){return t.group===e.group&&t.group?t.group>0:0!=(t.mask&e.category)&&0!=(e.mask&t.category)}static nextCategory(){return g.category=g.category<<1,g.category}static nextGroup(t=!1){return t?g.nonCollidingGroup--:g.group++}}g.category=1,g.group=1,g.nonCollidingGroup=-1;class y extends a{constructor(t){super(t)}update(){super.update();const t=this.engine.broadphase.pairs;for(const e of t.values())if(e.isActive){if((!e.isSleeping||!e.prev.isSleeping)&&(e.isActive=!1,e.bodyA.getBounds().overlaps(e.bodyB.getBounds())))for(const t of e.shapePairs.values())t.isActive&&(t.isActive=!1,g.canCollide(t.shapeA.filter,t.shapeB.filter)&&t.shapeA.getBounds().overlaps(t.shapeB.getBounds())&&(t.isActive=!0,e.isActive=!0));e.isActive&&(this.activePairsCount+=1,this.pairs.has(e.id)||this.pairs.set(e.id,e))}return this.pairs}}class f{constructor(t={}){this.id=o.nextId(),this.name="shape",this.body=void 0,this.position=new r,this.worldPosition=new r,this.bounds=new p,this.angle=0,this.inertia=t.inertia,this.area=0,this.filter=new g,t.filter&&(void 0!==t.filter.category&&(this.filter.category=t.filter.category),void 0!==t.filter.mask&&(this.filter.mask=t.filter.mask),void 0!==t.filter.group&&(this.filter.group=t.filter.group)),this.restitution=void 0!==t.restitution?t.restitution:.1,this.friction=void 0!==t.friction?t.friction:.1,this.frictionStatic=void 0!==t.frictionStatic?t.frictionStatic:.5}getWorldPosition(){return r.add(r.rotate(this.position,this.body.angle,this.worldPosition),this.body.position,this.worldPosition),this.worldPosition}getWorldAngle(){return this.angle+this.body.angle}updateArea(){}updateInertia(){}updateBounds(){}getBounds(){return this.updateBounds(),this.bounds}}f.AAB=Math.pow(2,0),f.CIRCLE=Math.pow(2,1),f.CONVEX=Math.pow(2,2);const v=t=>{const e=t.shapeA,s=t.shapeB,i=e.getWorldPosition(),n=s.getWorldPosition(),a=r.subtract(i,n,r.temp[0]),h=(e.width+s.width)/2-Math.abs(a.x),c=(e.height+s.height)/2-Math.abs(a.y);return h>0&&c>0&&(t.isActive=!0),t.contactsCount=2,h<c?(t.depth=h,r.set(t.normal,-o.sign(a.x),0),r.set(t.contacts[0].vertex,i.x-e.width/2*o.sign(a.x),Math.max(i.y-e.height/2,n.y-s.height/2)),r.set(t.contacts[1].vertex,i.x-e.width/2*o.sign(a.x),Math.min(i.y+e.height/2,n.y+s.height/2))):(t.depth=c,r.set(t.normal,0,-o.sign(a.y)),r.set(t.contacts[0].vertex,Math.max(i.x-e.width/2,n.x-s.width/2),i.y-e.height/2*o.sign(a.y)),r.set(t.contacts[1].vertex,Math.min(i.x+e.width/2,n.x+s.width/2),i.y-e.height/2*o.sign(a.y))),t},x=t=>{const e=t.shapeA.type===f.CIRCLE,s=e?t.shapeA:t.shapeB,i=e?t.shapeB:t.shapeA,n=s.getWorldPosition(),a=i.getWorldPosition(),h=r.subtract(n,a,r.temp[0]),c=r.clone(h,r.temp[1]);c.x=o.clamp(c.x,.5*-i.width,.5*i.width),c.y=o.clamp(c.y,.5*-i.height,.5*i.height);const l=o.contains(h.x,.5*-i.width,.5*i.width)&&o.contains(h.y,.5*-i.height,.5*i.height);l&&(.5*i.width-Math.abs(c.x)<.5*i.height-Math.abs(c.y)?c.x=.5*i.width*o.sign(c.x):c.y=.5*i.height*o.sign(c.y)),r.add(c,a),r.subtract(n,c,t.normal);const d=r.lengthSquared(t.normal);if(0===d)return t;const p=Math.pow(s.radius,2);if(p<d&&!l)return t;const u=Math.sqrt(d);return t.depth=p<d?s.radius+u:s.radius-u,r.divide(t.normal,u),l!==e&&r.neg(t.normal),t.contactsCount=1,r.clone(c,t.contacts[0].vertex),t.isActive=!0,t},b=t=>{const e=t.shapeA,s=t.shapeB,i=e.getWorldPosition(),o=s.getWorldPosition(),n=r.subtract(i,o,r.temp[0]),a=e.radius+s.radius,h=r.lengthSquared(n);if(h>Math.pow(a,2))return t;if(t.isActive=!0,t.contactsCount=1,h<=1e-5)return r.set(t.normal,0,1),t.depth=e.radius+s.radius,r.clone(i,t.contacts[0].vertex),t;const c=r.length(n);return t.depth=a-c,r.divide(n,-c,t.normal),r.clone(r.add(i,r.scale(t.normal,e.radius+(c-(e.radius+s.radius))/2,r.temp[0]),r.temp[0]),t.contacts[0].vertex),t},w={quickDecomp:function t(e,s,i,o,n,r,a){r=r||100,a=a||0,n=n||25,s=void 0!==s?s:[],i=i||[],o=o||[];var h=[0,0],c=[0,0],l=[0,0],d=0,p=0,u=0,m=0,g=0,y=0,f=0,v=[],x=[],b=e,w=e;if(w.length<3)return s;if(++a>r)return console.warn("quickDecomp: max level ("+r+") reached."),s;for(var A=0;A<e.length;++A)if(O(b,A)){i.push(b[A]),d=p=Number.MAX_VALUE;for(var P=0;P<e.length;++P)S(V(b,A-1),V(b,A),V(b,P))&&C(V(b,A-1),V(b,A),V(b,P-1))&&(l=j(V(b,A-1),V(b,A),V(b,P),V(b,P-1)),M(V(b,A+1),V(b,A),l)&&(u=T(b[A],l))<p&&(p=u,c=l,y=P)),S(V(b,A+1),V(b,A),V(b,P+1))&&C(V(b,A+1),V(b,A),V(b,P))&&(l=j(V(b,A+1),V(b,A),V(b,P),V(b,P+1)),S(V(b,A-1),V(b,A),l)&&(u=T(b[A],l))<d&&(d=u,h=l,g=P));if(y===(g+1)%e.length)l[0]=(c[0]+h[0])/2,l[1]=(c[1]+h[1])/2,o.push(l),A<g?(L(v,b,A,g+1),v.push(l),x.push(l),0!==y&&L(x,b,y,b.length),L(x,b,0,A+1)):(0!==A&&L(v,b,A,b.length),L(v,b,0,g+1),v.push(l),x.push(l),L(x,b,y,A+1));else{if(y>g&&(g+=e.length),m=Number.MAX_VALUE,g<y)return s;for(P=y;P<=g;++P)I(V(b,A-1),V(b,A),V(b,P))&&C(V(b,A+1),V(b,A),V(b,P))&&(u=T(V(b,A),V(b,P)))<m&&G(b,A,P)&&(m=u,f=P%e.length);A<f?(L(v,b,A,f+1),0!==f&&L(x,b,f,w.length),L(x,b,0,A+1)):(0!==A&&L(v,b,A,w.length),L(v,b,0,f+1),L(x,b,f,A+1))}return v.length<x.length?(t(v,s,i,o,n,r,a),t(x,s,i,o,n,r,a)):(t(x,s,i,o,n,r,a),t(v,s,i,o,n,r,a)),s}return s.push(e),s},decomp:function(t){var e=function t(e){for(var s=[],i=[],o=[],n=[],r=Number.MAX_VALUE,a=0;a<e.length;++a)if(O(e,a))for(var h=0;h<e.length;++h)if(D(e,a,h)){i=t(_(e,a,h,n)),o=t(_(e,h,a,n));for(var c=0;c<o.length;c++)i.push(o[c]);i.length<r&&(s=i,r=i.length,s.push([V(e,a),V(e,h)]))}return s}(t);return e.length>0?function t(e,s){if(0===s.length)return[e];if(s instanceof Array&&s.length&&s[0]instanceof Array&&2===s[0].length&&s[0][0]instanceof Array){for(var i=[e],o=0;o<s.length;o++)for(var n=s[o],r=0;r<i.length;r++){var a=i[r],h=t(a,n);if(h){i.splice(r,1),i.push(h[0],h[1]);break}}return i}n=s,o=e.indexOf(n[0]),r=e.indexOf(n[1]);return-1!==o&&-1!==r&&[_(e,o,r),_(e,r,o)]}(t,e):[t]},makeCCW:function(t){for(var e=0,s=t,i=1;i<t.length;++i)(s[i][1]<s[e][1]||s[i][1]===s[e][1]&&s[i][0]>s[e][0])&&(e=i);return!S(V(t,e-1),V(t,e),V(t,e+1))&&(function(t){for(var e=[],s=t.length,i=0;i!==s;i++)e.push(t.pop());for(i=0;i!==s;i++)t[i]=e[i]}(t),!0)},removeCollinearPoints:function(t,e){for(var s=0,i=t.length-1;t.length>3&&i>=0;--i)N(V(t,i-1),V(t,i),V(t,i+1),e)&&(t.splice(i%t.length,1),s++);return s}};function A(t,e,s){s=s||0;var i,o,n,r,a,h,c,l=[0,0];return i=t[1][1]-t[0][1],o=t[0][0]-t[1][0],n=i*t[0][0]+o*t[0][1],r=e[1][1]-e[0][1],a=e[0][0]-e[1][0],h=r*e[0][0]+a*e[0][1],q(c=i*a-r*o,0,s)||(l[0]=(a*n-o*h)/c,l[1]=(i*h-r*n)/c),l}function P(t,e,s,i){var o=e[0]-t[0],n=e[1]-t[1],r=i[0]-s[0],a=i[1]-s[1];if(r*n-a*o==0)return!1;var h=(o*(s[1]-t[1])+n*(t[0]-s[0]))/(r*n-a*o),c=(r*(t[1]-s[1])+a*(s[0]-t[0]))/(a*o-r*n);return h>=0&&h<=1&&c>=0&&c<=1}function B(t,e,s){return(e[0]-t[0])*(s[1]-t[1])-(s[0]-t[0])*(e[1]-t[1])}function S(t,e,s){return B(t,e,s)>0}function I(t,e,s){return B(t,e,s)>=0}function M(t,e,s){return B(t,e,s)<0}function C(t,e,s){return B(t,e,s)<=0}var E=[],W=[];function N(t,e,s,i){if(i){var o=E,n=W;o[0]=e[0]-t[0],o[1]=e[1]-t[1],n[0]=s[0]-e[0],n[1]=s[1]-e[1];var r=o[0]*n[0]+o[1]*n[1],a=Math.sqrt(o[0]*o[0]+o[1]*o[1]),h=Math.sqrt(n[0]*n[0]+n[1]*n[1]);return Math.acos(r/(a*h))<i}return 0===B(t,e,s)}function T(t,e){var s=e[0]-t[0],i=e[1]-t[1];return s*s+i*i}function V(t,e){var s=t.length;return t[e<0?e%s+s:e%s]}function L(t,e,s,i){for(var o=s;o<i;o++)t.push(e[o])}function O(t,e){return M(V(t,e-1),V(t,e),V(t,e+1))}var k=[],R=[];function D(t,e,s){var i,o,n=k,r=R;if(I(V(t,e+1),V(t,e),V(t,s))&&C(V(t,e-1),V(t,e),V(t,s)))return!1;o=T(V(t,e),V(t,s));for(var a=0;a!==t.length;++a)if((a+1)%t.length!==e&&a!==e&&I(V(t,e),V(t,s),V(t,a+1))&&C(V(t,e),V(t,s),V(t,a))&&(n[0]=V(t,e),n[1]=V(t,s),r[0]=V(t,a),r[1]=V(t,a+1),i=A(n,r),T(V(t,e),i)<o))return!1;return!0}function G(t,e,s){for(var i=0;i!==t.length;++i)if(i!==e&&i!==s&&(i+1)%t.length!==e&&(i+1)%t.length!==s&&P(V(t,e),V(t,s),V(t,i),V(t,i+1)))return!1;return!0}function _(t,e,s,i){var o=i||[];if(function(t){t.length=0}(o),e<s)for(var n=e;n<=s;n++)o.push(t[n]);else{for(n=0;n<=s;n++)o.push(t[n]);for(n=e;n<t.length;n++)o.push(t[n])}return o}function j(t,e,s,i,o){o=o||0;var n=e[1]-t[1],r=t[0]-e[0],a=n*t[0]+r*t[1],h=i[1]-s[1],c=s[0]-i[0],l=h*s[0]+c*s[1],d=n*c-h*r;return q(d,0,o)?[0,0]:[(c*a-r*l)/d,(n*l-h*a)/d]}function q(t,e,s){return s=s||0,Math.abs(t-e)<=s}const U={translate:(t,e)=>{for(let s=0;s<t.length;s++)r.add(t[s],e);return t},rotate:(t,e,s=t)=>{const i=Math.cos(e),o=Math.sin(e);for(let e=0;e<t.length;++e){const n=t[e],r=s[e],a=n.x,h=n.y;r.x=a*i-h*o,r.y=a*o+h*i}return s},scale:(t,e)=>{for(let s=0;s<t.length;s++)r.scale(t[s],e);return t},area:(t,e=!1)=>{let s=0,i=t.length-1;for(let e=0;e<t.length;++e)s+=(t[i].x-t[e].x)*(t[i].y+t[e].y),i=e;return s/2},inertia:t=>{let e=0,s=0;for(let i=0;i<t.length;++i){const o=(i+1)%t.length,n=Math.abs(r.cross(t[o],t[i]));e+=n*(r.dot(t[o],t[o])+r.dot(t[o],t[i])+r.dot(t[i],t[i])),s+=n}return e/s/6},center:t=>{const e=new r;for(let s=0;s<t.length;++s){const i=(s+1)%t.length,o=r.cross(t[s],t[i]),n=r.scale(r.add(t[s],t[i],r.temp[0]),o);r.add(e,n)}return r.divide(e,6*U.area(t)),e},contains:(t,e)=>{for(let s=0;s<t.length;++s){const i=t[s],o=t[(s+1)%t.length];if((e.x-i.x)*(o.y-i.y)+(e.y-i.y)*(i.x-o.x)>0)return!1}return!0},isConvex:t=>{let e=0;if(t.length<3)return null;for(let s=0;s<t.length;++s){const i=(s+1)%t.length,o=(s+2)%t.length,n=t[s],a=t[i],h=t[o],c=r.cross(r.subtract(a,n,r.temp[0]),r.subtract(h,n,r.temp[1]));if(c<0?e|=1:c>0&&(e|=2),3===e)return!1}return 0!==e||null},decomp:(t,e=!0,s=0)=>{const i=t.map(t=>[t.x,t.y]);if(w.makeCCW(i),U.isConvex(t)){return[i.map(t=>new r(t[0],t[1]))]}{const t=[],o=w.quickDecomp(i);for(const i of o){e&&w.removeCollinearPoints(i,.01);const o=i.map(t=>new r(t[0],t[1]));Math.abs(U.area(o))>s&&t.push(o)}return t}}},X=t=>{const e=t.shapeA,s=t.shapeB;let i;const o=Y(e,s,e.getWorldNormals());if(o.overlap<=0)return t;const n=Y(e,s,s.getWorldNormals());if(n.overlap<=0)return t;i=o.overlap<n.overlap?o:n,t.isActive=!0,t.depth=i.overlap,r.clone(i.normal,t.normal),r.dot(t.normal,r.subtract(e.getWorldPosition(),s.getWorldPosition(),r.temp[0]))>0&&r.neg(t.normal),t.contactsCount=0;const a=e.getWorldVertices(),h=s.getWorldVertices(),c=F(a,t.normal);for(const e of c){if(t.contactsCount>1)break;U.contains(h,e)&&(r.clone(e,t.contacts[t.contactsCount].vertex),t.contactsCount+=1)}const l=F(h,r.neg(t.normal,r.temp[3]));for(const e of l){if(t.contactsCount>1)break;U.contains(a,e)&&(r.clone(e,t.contacts[t.contactsCount].vertex),t.contactsCount+=1)}return 0===t.contactsCount&&(t.contactsCount=1,r.clone(c[0],t.contacts[0].vertex)),t},Y=(t,e,s)=>{const i={overlap:1/0};for(const o of s){const s=t.project(o),n=e.project(o),r=Math.min(s.max-n.min,n.max-s.min);if(r<=0)return i.overlap=r,i;r<i.overlap&&(i.overlap=r,i.normal=o)}return i},F=(t,e)=>{let s=1/0;const i=r.temp[1],o=r.temp[2];for(const o of t){-r.dot(e,o)<s&&(r.clone(o,i),i.index=o.index,s=-r.dot(e,o))}return-r.dot(e,t[i.index-1>=0?i.index-1:t.length-1])<-r.dot(e,t[(i.index+1)%t.length])?r.clone(t[i.index-1>=0?i.index-1:t.length-1],o):r.clone(t[(i.index+1)%t.length],o),[i,o]},K=t=>{const e=t.shapeA.type===f.CONVEX,s=e?t.shapeA:t.shapeB,i=e?t.shapeB:t.shapeA,o=i.getWorldPosition(),n=r.subtract(t.shapeB.getWorldPosition(),t.shapeA.getWorldPosition(),r.temp[0]),a=s.getWorldNormals(!1),h=s.getWorldVertices();let c,l=-1/0;for(const t of a){const e=r.dot(t,r.subtract(o,h[t.index],r.temp[1]));e>l&&(c=t.index,l=e)}const d=h[c];if(r.dot(r.subtract(o,d,r.temp[1]),a[c])>i.radius)return t;const p=h[(c+1)%h.length],u=r.temp[1];if(r.dot(r.subtract(o,d,r.temp[2]),r.subtract(p,d,r.temp[3]))<=0){r.clone(d,u),r.subtract(u,o,t.normal);const e=r.lengthSquared(t.normal);if(Math.pow(i.radius,2)<e)return t;if(0===e)return t;const s=Math.sqrt(e);t.depth=i.radius-s,r.divide(t.normal,s),t.isActive=!0}else{if(r.dot(r.subtract(o,p,r.temp[2]),r.subtract(d,p,r.temp[3]))<=0){r.clone(p,u),r.subtract(u,o,t.normal);const e=r.lengthSquared(t.normal);if(Math.pow(i.radius,2)<e)return t;if(0===e)return t;const s=Math.sqrt(e);t.depth=i.radius-s,r.divide(t.normal,s),t.isActive=!0}else r.clone(a[c],t.normal),r.dot(r.subtract(o,d,r.temp[1]),a[c])>0&&r.neg(t.normal),r.clone(r.subtract(o,r.scale(a[c],i.radius,r.temp[2]),r.temp[2]),u),t.depth=i.radius-l,t.isActive=!0}return r.dot(t.normal,n)<0&&r.neg(t.normal),t.contactsCount=1,r.clone(u,t.contacts[0].vertex),t},z=t=>{const e=t.shapeA.type===f.CONVEX,s=e?t.shapeA:t.shapeB,i=e?t.shapeB:t.shapeA;let o;const n=$(s,i);if(n.overlap<=0)return t;const a=H(s,i,s.getWorldNormals());if(a.overlap<=0)return t;o=n.overlap<a.overlap?n:a,t.isActive=!0,t.depth=o.overlap,r.clone(o.normal,t.normal),r.dot(t.normal,r.subtract(t.shapeA.getWorldPosition(),t.shapeB.getWorldPosition(),r.temp[0]))>0&&r.neg(t.normal),t.contactsCount=0;const h=t.shapeA.getWorldVertices(),c=t.shapeB.getWorldVertices(),l=Q(h,t.normal);for(const e of l){if(t.contactsCount>1)break;U.contains(c,e)&&(r.clone(e,t.contacts[t.contactsCount].vertex),t.contactsCount+=1)}const d=Q(c,r.neg(t.normal,r.temp[3]));for(const e of d){if(t.contactsCount>1)break;U.contains(h,e)&&(r.clone(e,t.contacts[t.contactsCount].vertex),t.contactsCount+=1)}return 0===t.contactsCount&&(t.contactsCount=1,r.clone(l[0],t.contacts[0].vertex)),t},H=(t,e,s)=>{const i={overlap:1/0};for(const o of s){const s=t.project(o),n=e.project(o),r=Math.min(s.max-n.min,n.max-s.min);if(r<=0)return i.overlap=r,i;r<i.overlap&&(i.overlap=r,i.normal=o)}return i},$=(t,e)=>{const s={},i=t.projectOnAxisX(),o=e.projectOnAxisX(),n=Math.min(i.max-o.min,o.max-i.min);if(n<=0)return s.overlap=n,s;const a=t.projectOnAxisY(),h=e.projectOnAxisY(),c=Math.min(a.max-h.min,h.max-a.min);return c<=0?(s.overlap=c,s):(n<c?(s.overlap=n,s.normal=new r(1,0)):(s.overlap=c,s.normal=new r(0,1)),s)},Q=(t,e)=>{let s=1/0;const i=r.temp[1],o=r.temp[2];for(const o of t){-r.dot(e,o)<s&&(r.clone(o,i),i.index=o.index,s=-r.dot(e,o))}return-r.dot(e,t[i.index-1>=0?i.index-1:t.length-1])<-r.dot(e,t[(i.index+1)%t.length])?r.clone(t[i.index-1>=0?i.index-1:t.length-1],o):r.clone(t[(i.index+1)%t.length],o),[i,o]},J={};J[f.AAB|f.AAB]=v,J[f.CIRCLE|f.AAB]=x,J[f.CIRCLE|f.CIRCLE]=b,J[f.CONVEX|f.AAB]=z,J[f.CONVEX|f.CIRCLE]=K,J[f.CONVEX|f.CONVEX]=X;class Z extends a{constructor(t){super(t),this.startedPairs=[],this.activePairs=[],this.endedPairs=[]}update(){super.update(),this.startedPairs.length=0,this.activePairs.length=0,this.endedPairs.length=0;const t=this.engine.midphase.pairs;for(const e of t.values())if(e.isActive){if(!e.isSleeping||!e.prev.isSleeping){e.isActive=!1,e.reset();for(const t of e.shapePairs.values())if(t.isActive&&(t.isActive=!1,J[t.shapeA.type|t.shapeB.type](t),t.isActive)){e.isActive=!0;for(let s=0;s<t.contactsCount;++s)e.contacts.push(t.contacts[s])}}e.isActive&&(this.activePairsCount+=1,this.pairs.has(e.id)||this.pairs.set(e.id,e)),e.isActive&&!e.prev.isActive&&this.startedPairs.push(e),!e.isActive&&e.prev.isActive&&this.endedPairs.push(e),e.isActive&&this.activePairs.push(e)}else e.prev.isActive&&this.endedPairs.push(e);return this.pairs}}class tt{constructor(t){this.engine=t,this.positionIterations=5,this.velocityIterations=5,this.constraintIterations=5}update(){const t=this.engine.narrowphase.activePairs;for(const e of t)if(!e.isSleeping)for(const t of e.shapePairs.values())t.isActive&&t.update();this.preSolvePosition();for(let t=0;t<this.positionIterations;++t)this.solvePosition();this.postSolvePosition(),this.preSolveConstraints();for(let t=0;t<this.constraintIterations;++t)this.solveConstraints();this.preSolveVelocity();for(let t=0;t<this.velocityIterations;++t)this.solveVelocity()}preSolvePosition(){const t=this.engine.narrowphase.activePairs,e=this.engine.world.allBodies();for(const t of e)t.contactsCount=0;for(const e of t)e.bodyA.contactsCount+=e.contacts.length,e.bodyB.contactsCount+=e.contacts.length}solvePosition(){const t=this.engine.narrowphase.activePairs;for(const e of t)if(!e.isSleeping)for(const t of e.shapePairs.values())t.isActive&&(t.separation=r.dot(t.normal,r.subtract(t.penetration,r.subtract(e.bodyB.positionImpulse,e.bodyA.positionImpulse,r.temp[0]),r.temp[1])));for(const e of t)if(!e.isSleeping)for(const t of e.shapePairs.values()){if(!t.isActive)continue;const s=(t.separation-tt.SLOP)*(e.bodyA.isStatic||e.bodyB.isStatic?1:.5);if(!e.bodyA.isStatic&&e.bodyA.sleepState!==u.SLEEPING){const i=tt.DEPTH_DAMPING/e.bodyA.contactsCount;e.bodyA.positionImpulse.x-=t.normal.x*s*i,e.bodyA.positionImpulse.y-=t.normal.y*s*i}if(!e.bodyB.isStatic&&e.bodyB.sleepState!==u.SLEEPING){const i=tt.DEPTH_DAMPING/e.bodyB.contactsCount;e.bodyB.positionImpulse.x+=t.normal.x*s*i,e.bodyB.positionImpulse.y+=t.normal.y*s*i}}}postSolvePosition(){const t=this.engine.world.allBodies();for(const e of t)e.isStatic||e.sleepState===u.SLEEPING||(r.add(e.position,e.positionImpulse),r.dot(e.positionImpulse,e.velocity)>0?r.set(e.positionImpulse,0,0):r.scale(e.positionImpulse,tt.POSITION_IMPULSE_DAMPING))}preSolveVelocity(){const t=this.engine.narrowphase.activePairs;for(const e of t)if(!e.isSleeping)for(const t of e.shapePairs.values())if(t.isActive)for(let s=0;s<t.contactsCount;++s){const i=t.contacts[s],o=r.scale(t.normal,i.normalImpulse,r.temp[0]);if(!e.bodyA.isStatic&&e.bodyA.sleepState!==u.SLEEPING){const t=r.subtract(i.vertex,e.bodyA.position,r.temp[2]);e.bodyA.velocity.x-=o.x*e.bodyA.inverseMass,e.bodyA.velocity.y-=o.y*e.bodyA.inverseMass,e.bodyA.angularVelocity-=r.cross(t,o)*e.bodyA.inverseInertia}if(!e.bodyB.isStatic&&e.bodyB.sleepState!==u.SLEEPING){const t=r.subtract(i.vertex,e.bodyB.position,r.temp[2]);e.bodyB.velocity.x+=o.x*e.bodyB.inverseMass,e.bodyB.velocity.y+=o.y*e.bodyB.inverseMass,e.bodyB.angularVelocity+=r.cross(t,o)*e.bodyB.inverseInertia}}}solveVelocity(){const t=this.engine.narrowphase.activePairs;for(const e of t){if(e.isSleeping)continue;const t=1/e.contacts.length,s=r.clone(e.bodyA.velocity),i=e.bodyA.angularVelocity,o=r.clone(e.bodyB.velocity),n=e.bodyB.angularVelocity;for(const a of e.shapePairs.values())if(a.isActive)for(let h=0;h<a.contactsCount;++h){const c=a.contacts[h],l=r.subtract(c.vertex,e.bodyA.position,r.temp[0]),d=r.subtract(c.vertex,e.bodyB.position,r.temp[1]),p=r.add(s,r.scale(r.rotate90(l,r.temp[2]),i),r.temp[2]),m=r.add(o,r.scale(r.rotate90(d,r.temp[3]),n),r.temp[3]),g=r.subtract(p,m,r.temp[4]),y=r.cross(l,a.normal),f=r.cross(d,a.normal),v=t/(e.bodyA.inverseMass+e.bodyB.inverseMass+e.bodyA.inverseInertia*Math.pow(y,2)+e.bodyB.inverseInertia*Math.pow(f,2)),x=r.dot(g,a.normal);let b=(1+a.restitution)*x*v;if(x>tt.RESTING_THRESHOLD)c.normalImpulse=0;else{const t=c.normalImpulse;c.normalImpulse=Math.max(c.normalImpulse+b,0),b=c.normalImpulse-t}const w=r.dot(g,a.tangent);let A=w*v;Math.abs(w)>-a.frictionStatic*x&&(A*=a.friction);const P=r.add(r.scale(a.normal,b,r.temp[5]),r.scale(a.tangent,A,r.temp[6]));e.bodyA.isStatic||e.bodyA.sleepState===u.SLEEPING||(e.bodyA.velocity.x-=P.x*e.bodyA.inverseMass,e.bodyA.velocity.y-=P.y*e.bodyA.inverseMass,e.bodyA.angularVelocity-=r.cross(l,P)*e.bodyA.inverseInertia),e.bodyB.isStatic||e.bodyB.sleepState===u.SLEEPING||(e.bodyB.velocity.x+=P.x*e.bodyB.inverseMass,e.bodyB.velocity.y+=P.y*e.bodyB.inverseMass,e.bodyB.angularVelocity+=r.cross(d,P)*e.bodyB.inverseInertia)}}}preSolveConstraints(){const t=this.engine.world.allBodies();for(const e of t)e.isStatic||e.sleepState===u.SLEEPING||(e.constraintImpulse.x*=tt.CONSTRAINT_IMPULSE_DAMPING,e.constraintImpulse.y*=tt.CONSTRAINT_IMPULSE_DAMPING,e.constraintImpulse.angle*=tt.CONSTRAINT_IMPULSE_DAMPING,e.position.x+=e.constraintImpulse.x,e.position.y+=e.constraintImpulse.y,e.angle+=e.constraintImpulse.angle,e.velocity.x+=e.constraintImpulse.x,e.velocity.y+=e.constraintImpulse.y,e.angularVelocity+=e.constraintImpulse.angle)}solveConstraints(){const t=this.engine.world.allConstraints();for(const e of t)e.solve()}}tt.SLOP=.005,tt.DEPTH_DAMPING=.8,tt.POSITION_IMPULSE_DAMPING=.8,tt.CONSTRAINT_IMPULSE_DAMPING=.4,tt.RESTING_THRESHOLD=.08;class et{constructor(t={}){this.id=o.nextId(),this.name="body",this.shapes=[],this.shapesBounds=[],this.bounds=new p,this.boundsNeedsUpdate=!0,this.events=new i,this.positionImpulse=new r,this.constraintImpulse=new r,this.constraintImpulse.angle=0,this.contactsCount=0,this.angularAcceleration=0,this.angle=0,this.anglePrev=0,this.angularVelocity=0,this.torque=0,this.position=new r,this.positionPrev=new r,this.acceleration=new r,this.velocity=new r,this.force=new r,this.isStatic=!1,this.velocityDamping=5e-4,this.density=100,this.mass=0,this.inverseMass=0,this.inertia=0,this.inverseInertia=0,this.area=0,this.sleepState=u.AWAKE,this.motion=0,this.sleepyTimer=0,this.set(t)}set(t){for(const e of Object.entries(t))switch(e[0]){case"position":this.setPosition(e[1]);break;case"angle":this.setAngle(e[1]);break;case"mass":this.setMass(e[1]);break;case"density":this.setDensity(e[1]);break;case"isStatic":this.setStatic(e[1]);break;case"velocityDamping":this.velocityDamping=e[1]}}update(t){this.isStatic||this.sleepState===u.SLEEPING||(r.scale(this.force,this.inverseMass*t,this.acceleration),r.add(r.scale(this.velocity,1-this.velocityDamping),r.scale(this.acceleration,t)),r.clone(this.position,this.positionPrev),r.add(this.position,this.velocity,this.position),this.angularAcceleration=this.torque*this.inverseInertia*t,this.angularVelocity=this.angularVelocity*(1-this.velocityDamping)+this.angularAcceleration*t,this.anglePrev=this.angle,this.angle+=this.angularVelocity,r.set(this.force,0,0),this.torque=0,this.boundsNeedsUpdate=!0)}addShape(t,e=!1,s=new r,i=0){r.add(t.position,s),t.angle+=i,t.body=this,this.shapes.push(t),this.updateArea(),e&&this.updateCenterOfMass(),this.updateMass(),this.updateInertia(),this.boundsNeedsUpdate=!0,this.events.trigger("addShape",[{shape:t,updateCenterOfMass:e,offset:s,angle:i,body:this}])}updateArea(){this.area=0;for(const t of this.shapes)this.area+=t.area}updateInertia(){let t=0;if(this.isStatic)this.inertia=0,this.inverseInertia=0;else for(const e of this.shapes){const s=r.length(e.position);t+=e.inertia+s}this.inertia=this.mass*t,this.inverseInertia=0===this.inertia?0:1/this.inertia}updateMass(){this.isStatic?(this.mass=0,this.inverseMass=0):(this.mass=this.area*this.density,this.inverseMass=0===this.mass?0:1/this.mass)}updateBounds(){if(this.boundsNeedsUpdate){this.shapesBounds.length=0;for(const t of this.shapes)this.shapesBounds.push(t.updateBounds());p.combine(this.shapesBounds,this.bounds),this.boundsNeedsUpdate=!1}}updateCenterOfMass(){const t=r.temp[0];r.set(t,0,0);for(const e of this.shapes)r.add(t,r.scale(e.position,e.area,r.temp[1]));const e=r.scale(t,1/this.area,r.temp[1]);for(const t of this.shapes)r.subtract(t.position,e);this.setPosition(r.add(this.position,e,r.temp[2]))}setPosition(t){r.clone(t,this.position),this.boundsNeedsUpdate=!0}translate(t){r.add(this.position,t),this.boundsNeedsUpdate=!0}setAngle(t){this.angle=t,this.boundsNeedsUpdate=!0}rotate(t){this.angle+=t,this.boundsNeedsUpdate=!0}setMass(t){this.density=0===this.area?0:t/this.area,this.updateMass(),this.updateInertia()}setDensity(t){this.density=t,this.updateMass(),this.updateInertia()}getBounds(){return this.updateBounds(),this.bounds}setStatic(t){this.isStatic=t,t&&(r.set(this.acceleration,0,0),r.set(this.velocity,0,0),r.set(this.force,0,0),this.angularAcceleration=0,this.angularVelocity=0,this.torque=0,r.set(this.positionImpulse,0,0)),this.updateMass(),this.updateInertia()}setSleeping(t){this.sleepState=t,this.sleepState===u.SLEEPING?(this.sleepyTimer=u.sleepyTimeLimit,r.set(this.positionImpulse,0,0),r.set(this.velocity,0,0),this.angularVelocity=0,this.motion=0):this.sleepState===u.AWAKE&&(this.sleepyTimer=0)}applyForce(t,e){r.add(this.force,t),e&&(this.torque+=r.cross(e,t))}setVelocity(t){r.clone(t,this.velocity)}}class st extends f{constructor(t={}){super(t),this.label="circle",this.type=f.CIRCLE,this.radius=t.radius||.5,this.updateArea(),this.inertia||(this.inertia=this.updateInertia())}updateArea(){return this.area=Math.PI*Math.pow(this.radius,2),this.area}updateInertia(){return this.inertia=Math.pow(this.radius,2)/2,this.inertia}updateBounds(){return r.set(this.bounds.min,-this.radius,-this.radius),r.set(this.bounds.max,this.radius,this.radius),this.bounds.translate(this.getWorldPosition()),this.bounds}}class it extends f{constructor(t={}){if(super(t),this.label="convex",this.type=f.CONVEX,this.vertices=[],t.vertices)for(const e of t.vertices)this.vertices.push(r.clone(e));else this.vertices.push(new r(-1,-1)),this.vertices.push(new r(1,-1)),this.vertices.push(new r(1,1)),this.vertices.push(new r(-1,1));this.updateArea(),this.area<=0&&(this.area=-this.area,this.vertices.reverse()),this.updateCenterOfMass(),this.updateVertices(),this.createNormals(),this.inertia||(this.inertia=this.updateInertia())}updateVertices(){this.worldVertices=[];for(let t=0;t<this.vertices.length;++t)this.worldVertices.push(r.clone(this.vertices[t])),this.vertices[t].index=t,this.worldVertices[t].index=t}getWorldVertices(){this.getWorldPosition();for(let t=0;t<this.vertices.length;++t)r.rotate(this.vertices[t],this.getWorldAngle(),this.worldVertices[t]),r.add(this.worldVertices[t],this.worldPosition);return this.worldVertices}createNormals(){this.allNormals=[];const t={};for(let e=0;e<this.vertices.length;++e){const s=(e+1)%this.vertices.length,i=r.subtract(this.vertices[e],this.vertices[s],new r);r.rotate90(i),r.normalise(i),i.index=e,this.allNormals.push(i),t[(0===i.y?1/0:i.x/i.y).toFixed(2)]=i}this.normals=Object.values(t);for(let t=0;t<this.normals.length;++t){const e=this.normals[t].index;this.normals[t]=r.clone(this.normals[t]),this.normals[t].index=e}this.worldNormals=[];for(const t of this.normals){const e=new r;e.index=t.index,this.worldNormals.push(e)}this.allWorldNormals=[];for(const t of this.allNormals){const e=new r;e.index=t.index,this.allWorldNormals.push(e)}}getWorldNormals(t=!0){const e=this.getWorldAngle(),s=Math.cos(e),i=Math.sin(e),o=t?this.normals:this.allNormals,n=t?this.worldNormals:this.allWorldNormals;for(let t=0;t<o.length;++t)n[t].x=o[t].x*s-o[t].y*i,n[t].y=o[t].x*i+o[t].y*s;return n}project(t){const e=this.getWorldVertices(),s=r.dot(e[0],t),i={min:s,max:s};for(const s of e){const e=r.dot(s,t);e>i.max?i.max=e:e<i.min&&(i.min=e)}return i}projectOnAxisX(){const t=this.getWorldVertices(),e=t[0].x,s={min:e,max:e};for(const e of t){const t=e.x;t>s.max?s.max=t:t<s.min&&(s.min=t)}return s}projectOnAxisY(){const t=this.getWorldVertices(),e=t[0].y,s={min:e,max:e};for(const e of t){const t=e.y;t>s.max?s.max=t:t<s.min&&(s.min=t)}return s}updateArea(){return this.area=U.area(this.vertices),this.area}updateInertia(){return this.inertia=U.inertia(this.vertices),this.inertia}updateBounds(){return this.bounds.fromVertices(this.getWorldVertices()),this.bounds}updateCenterOfMass(){const t=U.center(this.vertices);r.add(this.position,t);for(const e of this.vertices)r.subtract(e,t)}}class ot{constructor(t={}){this.stiffness=t.stiffness||.2,this.damping=t.damping||0}}ot.DISTANCE_EQUATION=0,ot.ANGLE_EQYATION=1;class nt extends ot{constructor(t={}){super(t),this.type=ot.DISTANCE_EQUATION}solve(t){const e=t.fromBtoA,s=t.dist,i=t.offsetA,o=t.offsetB,n=t.mass,a=t.inertia,h=r.scale(e,this.stiffness*(s-this.constraint.length)/s,r.temp[3]),c=r.temp[4];if(this.damping){r.subtract(this.constraint.bodyB?this.constraint.bodyB.velocity:r.zero,this.constraint.bodyA?this.constraint.bodyA.velocity:r.zero,c);const t=r.divide(e,s,r.temp[5]),i=r.dot(c,t);r.scale(t,i,c)}if(this.constraint.bodyA&&!this.constraint.bodyA.isStatic){this.constraint.bodyA.setSleeping(u.AWAKE);const t=this.constraint.bodyA.inverseMass/n,e=h.x*t,s=h.y*t,o=r.cross(i,h)*(this.constraint.bodyA.inverseInertia/a);if(this.constraint.bodyA.constraintImpulse.x-=e,this.constraint.bodyA.constraintImpulse.y-=s,this.constraint.bodyA.constraintImpulse.angle-=o,this.constraint.bodyA.position.x-=e,this.constraint.bodyA.position.y-=s,this.constraint.bodyA.angle-=o,this.constraint.bodyA.velocity.x-=e,this.constraint.bodyA.velocity.y-=s,this.constraint.bodyA.angularVelocity-=o,this.damping){const e=r.scale(c,this.damping*t,r.temp[6]);this.constraint.bodyA.velocity.x+=e.x,this.constraint.bodyA.velocity.y+=e.y}}if(this.constraint.bodyB&&!this.constraint.bodyB.isStatic){this.constraint.bodyB.setSleeping(u.AWAKE);const t=this.constraint.bodyB.inverseMass/n,e=h.x*t,s=h.y*t,i=r.cross(o,h)*(this.constraint.bodyB.inverseInertia/a);if(this.constraint.bodyB.constraintImpulse.x+=e,this.constraint.bodyB.constraintImpulse.y+=s,this.constraint.bodyB.constraintImpulse.angle+=i,this.constraint.bodyB.position.x+=e,this.constraint.bodyB.position.y+=s,this.constraint.bodyB.angle+=i,this.constraint.bodyB.velocity.x+=e,this.constraint.bodyB.velocity.y+=s,this.constraint.bodyB.angularVelocity+=i,this.damping){const e=r.scale(c,this.damping*t,r.temp[6]);this.constraint.bodyB.velocity.x-=e.x,this.constraint.bodyB.velocity.y-=e.y}}}}class rt{constructor(t={}){this.id=o.nextId(),this.name="constraint",this.bodyA=t.bodyA,this.bodyB=t.bodyB,this.pointA=t.pointA?r.clone(t.pointA):new r,this.pointB=t.pointB?r.clone(t.pointB):new r,this.worldPointA=this.bodyA?new r:r.clone(this.pointA),this.worldPointB=this.bodyB?new r:r.clone(this.pointB),this.equations=[],this.length=t.length,this.length||(this.getWorldPointA(),this.getWorldPointB(),this.length=r.length(r.subtract(this.worldPointA,this.worldPointB,r.temp[0])))}solve(){this.getWorldPointA(),this.getWorldPointB();const t=r.subtract(this.worldPointA,this.worldPointB,r.temp[0]),e=Math.max(r.length(t),.001),s=this.bodyA?r.subtract(this.worldPointA,this.bodyA.position,r.temp[1]):void 0,i=this.bodyB?r.subtract(this.worldPointB,this.bodyB.position,r.temp[2]):void 0,o=(this.bodyA?this.bodyA.inverseMass:0)+(this.bodyB?this.bodyB.inverseMass:0),n={fromBtoA:t,dist:e,offsetA:s,offsetB:i,mass:o,inertia:(this.bodyA?this.bodyA.inverseInertia:0)+(this.bodyB?this.bodyB.inverseInertia:0)+o,worldPointA:this.worldPointA,worldPointB:this.worldPointB};for(const t of this.equations)t.solve(n)}addEquation(t){Array.isArray(t)||(t=[t]);for(const e of t)e.constraint=this,this.equations.push(e)}getWorldPointA(){return this.bodyA?(r.rotate(this.pointA,this.bodyA.angle,this.worldPointA),r.add(this.worldPointA,this.bodyA.position)):r.clone(this.pointA,this.worldPointA),this.worldPointA}getWorldPointB(){return this.bodyB?(r.rotate(this.pointB,this.bodyB.angle,this.worldPointB),r.add(this.worldPointB,this.bodyB.position)):r.clone(this.pointB,this.worldPointB),this.worldPointB}}const at={rectangle:(t,e,s,i={},o={})=>{i.position=t,o.vertices=[new r(-e/2,-s/2),new r(e/2,-s/2),new r(e/2,s/2),new r(-e/2,s/2)];const n=new et(i);return n.addShape(new it(o)),n},circle:(t,e,s={},i={})=>{s.position=t;const o=new et(s);return i.radius=e,o.addShape(new st(i)),o},polygon:(t,e=4,s=2,i={},o={})=>{const n=2*Math.PI/e,a=[];for(let t=0;t<e;++t){const e=n*t;a.push(new r(Math.cos(e)*s,Math.sin(e)*s))}i.position=t,o.vertices=a;const h=new et(i);return h.addShape(new it(o)),h},chain:(t,e,s,i={},o={})=>{const n=t.allBodies();for(let a=1;a<n.length;++a){const h=n[a-1],c=n[a],l=h.getBounds(),d=c.getBounds();i.bodyA=h,i.bodyB=c,e&&(i.pointA=r.set(r.temp[0],l.getWidth()*e.x*.5,l.getHeight()*e.y*.5)),s&&(i.pointB=r.set(r.temp[1],d.getWidth()*s.x*.5,d.getHeight()*s.y*.5));const p=new rt(i),u=new nt(o);p.addEquation(u),t.addConstraint(p)}return t},car:(t,e=1,s=new n)=>{const i=g.nextGroup(!0),o=new et({position:t});o.addShape(new it({vertices:[new r(-1.5*e,.5*e),new r(1.5*e,.5*e),new r(1.5*e,0),new r(0,-.9*e),new r(-1.15*e,-.9*e),new r(-1.5*e,-.2*e)],filter:{group:i}}));const a=new et({position:new r(t.x+e,t.y+.5*e)});a.addShape(new st({radius:.4*e,filter:{group:i}}));const h=new et({position:new r(t.x-e,t.y+.5*e)});h.addShape(new st({radius:.4*e,filter:{group:i}}));const c=new rt({bodyA:o,bodyB:a,pointA:new r(e,.5*e)}),l=new nt({stiffness:1});c.addEquation(l);const d=new rt({bodyA:o,bodyB:h,pointA:new r(-e,.5*e)}),p=new nt({stiffness:1});return d.addEquation(p),s.addBody([o,a,h]),s.addConstraint([c,d]),s},newtonsCradle:(t,e,s,i,o=1,a=0,h=new n)=>{const c=s*e-s,l=i/2+s;for(let i=0;i<e;++i){const n=new et({position:new r(i*s*2+t.x-c,t.y+l),velocityDamping:0});n.addShape(new st({radius:s,inertia:1/0,restitution:1,friction:0,frictionStatic:0})),i<o?(n.position.x-=2*l,n.position.y-=2*l):i>e-a-1&&(n.position.x+=2*l,n.position.y-=2*l);const d=new rt({bodyA:n,pointB:new r(i*s*2+t.x-c,t.y-l)}),p=new nt({stiffness:1});d.addEquation(p),h.addBody(n),h.addConstraint(d)}return h},fromVertices:(t,e,s={},i={})=>{const o=U.decomp(e);s.position=t;const n=new et(s);for(const t of o)i.vertices=t,n.addShape(new it(i),!1);return n.updateCenterOfMass(),n}};class ht{constructor(t){this.render=t,this.events=new i,this.pressed=!1,this.leftButtonPressed=!1,this.rightButtonPressed=!1,this.wheelButtonPressed=!1,this.localPosition=new r,this.position=new r,this.localMovement=new r,this.movement=new r,this.scroll=new r,this.holdsBody=!1,this.render.canvas.addEventListener("mousedown",t=>{this.mouseDown(t)}),this.render.canvas.addEventListener("mouseup",t=>{this.mouseUp(t)}),this.render.canvas.addEventListener("mousemove",t=>{this.mouseMove(t)}),this.render.canvas.addEventListener("wheel",t=>{this.mouseWheel(t)})}mouseDown(t){this.pressed=!0,0===t.button?this.leftButtonPressed=!0:1===t.button?this.wheelButtonPressed=!0:2===t.button&&(this.rightButtonPressed=!0),r.set(this.localPosition,t.clientX,t.clientY),this.updatePosition(),this.events.trigger("mousedown",[this])}mouseUp(t){t.buttons<=0&&(this.pressed=!1),0===t.button?this.leftButtonPressed=!1:1===t.button?this.wheelButtonPressed=!1:2===t.button&&(this.rightButtonPressed=!1),r.set(this.localPosition,t.clientX,t.clientY),this.updatePosition(),this.events.trigger("mouseup",[this])}mouseMove(t){r.set(this.localPosition,t.clientX,t.clientY),this.updatePosition(),r.set(this.localMovement,t.movementX,t.movementY),this.updateMovement(),this.events.trigger("mousemove",[this])}mouseWheel(t){this.events.trigger("wheel",[t])}updatePosition(){r.set(this.position,(this.localPosition.x-this.render.canvas.width/2)/this.render.options.scale.x-this.render.options.translate.x,(this.localPosition.y-this.render.canvas.height/2)/this.render.options.scale.y-this.render.options.translate.y)}updateMovement(){r.set(this.movement,this.localMovement.x/this.render.options.scale.x,this.localMovement.y/this.render.options.scale.y)}}const ct={rect:(t,e,s,i,o,n,r=!0,a=1)=>{o&&Math.abs(o%Math.PI*.5)>.025?(t.save(),t.translate(e.x,e.y),t.rotate(o),r?(t.fillStyle=n,t.fillRect(.5*-s,.5*-i,s,i)):(t.strokeStyle=n,t.lineWidth=a,t.strokeRect(.5*-s,.5*-i,s,i)),t.restore()):r?(t.fillStyle=n,t.fillRect(e.x-.5*s,e.y-.5*i,s,i)):(t.strokeStyle=n,t.lineWidth=a,t.strokeRect(e.x-.5*s,e.y-.5*i,s,i))},circle:(t,e,s,i,o=!0,n=1)=>{t.beginPath(),t.arc(e.x,e.y,s,0,2*Math.PI),o?(t.fillStyle=i,t.fill()):(t.lineWidth=n,t.strokeStyle=i,t.stroke()),t.closePath()},roundedRect:(t,e,s,i,o,n,r,a=!0,h=1)=>{n||ct.rect(t,e,s,i,o,r,a,h),t.save(),t.translate(e.x,e.y),o&&t.rotate(o);const c=.5*s,l=.5*i,d=Math.min(c,l)*(n=Math.min(Math.max(n,0),1));t.beginPath(),t.moveTo(-c,-l+d),t.arcTo(-c,-l,-c+d,-l,d),t.moveTo(c-d,-l),t.arcTo(c,-l,c,-l+d,d),t.moveTo(c,l-d),t.arcTo(c,l,c-d,l,d),t.moveTo(-c+d,l),t.arcTo(-c,l,-c,l-d,d),t.moveTo(-c,-l+d),t.lineTo(-c+d,-l),t.lineTo(c-d,-l),t.lineTo(c,-l+d),t.lineTo(c,l-d),t.lineTo(c-d,l),t.lineTo(-c+d,l),t.lineTo(-c,l-d),t.lineTo(-c,-l+d),t.closePath(),a?(t.fillStyle=r,t.fill()):(t.lineWidth=h,t.strokeStyle=r,t.stroke()),t.restore()},polygon:(t,e,s,i=!0,o=1)=>{t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let s=0;s<e.length;++s)t.lineTo(e[s].x,e[s].y);t.lineTo(e[0].x,e[0].y),t.closePath(),i?(t.fillStyle=s,t.fill()):(t.lineWidth=o,t.strokeStyle=s,t.stroke())},line:(t,e,s,i,o=1)=>{t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(s.x,s.y),t.closePath(),t.lineWidth=o,t.strokeStyle=i,t.stroke()}};const lt={Composite:n,Engine:class{constructor(t={}){this.world=t.world||new n,this.gravity=void 0===t.gravity?new r(0,9.8):r.clone(t.gravity),this.broadphase=new m(this),this.midphase=new y(this),this.narrowphase=new Z(this),this.solver=new tt(this),this.sleeping=new u(this),this.events=new i,this.runner=t.runner,this.runner&&this.runner.events.on("update",t=>{this.update(t)}),this.world.events.on("beforeRemove",t=>{"body"===t.object.name&&this.broadphase.removeBodyFromGrid(t.object)})}update(t){this.timestamp=t,this.events.trigger("beforeUpdate",[{engine:this,timestamp:t}]),this.events.trigger("update",[{engine:this,timestamp:t}]),this.sleeping.update(t.delta),this.applyGravity(),this.updateBodies(t.delta),this.broadphase.update(),this.midphase.update(),this.narrowphase.update(),this.sleeping.afterCollisions(),this.narrowphase.startedPairs.length&&this.events.trigger("startedPairs",[{pairs:this.narrowphase.startedPairs}]),this.solver.update(),this.narrowphase.activePairs.length&&this.events.trigger("activePairs",[{pairs:this.narrowphase.activePairs}]),this.narrowphase.endedPairs.length&&this.events.trigger("endedPairs",[{pairs:this.narrowphase.endedPairs}]),this.events.trigger("afterUpdate",[{engine:this,timestamp:t}])}applyGravity(){for(const t of this.world.allBodies())t.isStatic||t.sleepState===u.SLEEPING||(t.force.x+=this.gravity.x*t.mass,t.force.y+=this.gravity.y*t.mass)}updateBodies(t){for(const e of this.world.allBodies())e.update(t)}},Events:i,Body:et,Shape:f,AAB:class extends f{constructor(t={}){super(t),this.label="aab",this.type=f.AAB,this.width=t.width||1,this.height=t.height||1,this.updateArea(),this.inertia=1/0,this.createVertices()}createVertices(){this.vertices=[],this.vertices.push(new r(-this.width/2,-this.height/2)),this.vertices.push(new r(this.width/2,-this.height/2)),this.vertices.push(new r(this.width/2,this.height/2)),this.vertices.push(new r(-this.width/2,this.height/2)),this.worldVertices=[];for(let t=0;t<4;++t)this.worldVertices.push(new r),this.worldVertices[t].index=t,this.vertices[t].index=t}getWorldVertices(){const t=this.getWorldPosition();for(let e=0;e<this.vertices.length;++e)r.add(this.vertices[e],t,this.worldVertices[e]);return this.worldVertices}project(t){const e=this.getWorldVertices(),s=r.dot(e[0],t),i={min:s,max:s};for(const s of e){const e=r.dot(s,t);e>i.max?i.max=e:e<i.min&&(i.min=e)}return i}projectOnAxisX(){return{min:this.getWorldPosition().x-this.width/2,max:this.getWorldPosition().x+this.width/2}}projectOnAxisY(){return{min:this.getWorldPosition().y-this.height/2,max:this.getWorldPosition().y+this.height/2}}getWorldAngle(){return 0}updateArea(){return this.area=this.width*this.height,this.area}updateInertia(){return this.inertia=(Math.pow(this.width,2)+Math.pow(this.height,2))/12,this.inertia}updateBounds(){return r.set(this.bounds.min,-this.width/2,-this.height/2),r.set(this.bounds.max,this.width/2,this.height/2),this.bounds.translate(this.getWorldPosition()),this.bounds}},Circle:st,Convex:it,Filter:g,Sleeping:u,Bounds:p,Common:o,Grid:d,Vector:r,Vertices:U,AABVsAAB:v,CircleVsAAB:x,CircleVsCircle:b,ConvexVsAAB:z,ConvexVsCircle:K,ConvexVsConvex:X,Colliders:J,Phase:a,Broadphase:m,Midphase:y,Narrowphase:Z,Contact:c,Pair:h,ShapePair:l,Solver:tt,Equation:ot,DistanceEquation:nt,Constraint:rt,Factory:at,Mouse:ht,MouseConstraint:class{constructor(t,e,s=[new nt({stiffness:.2})]){this.engine=t,this.mouse=e,this.constraint=new rt({length:0}),this.constraint.addEquation(s),this.events=new i,t.world.addConstraint(this.constraint),this.mouse.events.on("mousedown",t=>{this.mouseDown(t)}),this.mouse.events.on("mouseup",t=>{this.mouseUp(t)}),this.mouse.events.on("mousemove",t=>{this.mouseMove(t)})}mouseDown(t){if(this.mouse.leftButtonPressed&&this.constraint){const e=this.engine.world.allBodies();for(const s of e)if(!s.isStatic&&s.getBounds().contains(t.position))for(const e of s.shapes)if(e.getBounds().contains(t.position)){if(e.type===f.AAB){this.constraint.bodyA=s,r.rotate(r.subtract(t.position,s.position,this.constraint.pointA),-s.angle),this.events.trigger("catchBody",[{body:s,shape:e}]);break}if(e.type===f.CIRCLE&&r.lengthSquared(r.subtract(t.position,e.getWorldPosition(),r.temp[0]))<Math.pow(e.radius,2)){this.constraint.bodyA=s,r.rotate(r.subtract(t.position,s.position,this.constraint.pointA),-s.angle),this.events.trigger("catchBody",[{body:s,shape:e}]);break}if(e.type===f.CONVEX&&U.contains(e.getWorldVertices(),t.position)){this.constraint.bodyA=s,r.rotate(r.subtract(t.position,s.position,this.constraint.pointA),-s.angle),this.events.trigger("catchBody",[{body:s,shape:e}]);break}}}}mouseUp(t){this.mouse.leftButtonPressed||(this.constraint.bodyA=void 0)}mouseMove(t){r.clone(t.position,this.constraint.pointB)}},Render:class{constructor(t,e={}){this.engine=t,this.events=new i,this.options={scale:new r(20,20),translate:new r,lineWidth:1,backgroundColor:e.backgroundColor||"rgb(16, 24, 24)",showBodies:void 0===e.showBodies||e.showBodies,showConstraints:void 0===e.showConstraints||e.showConstraints,showAngleIndicator:void 0===e.showAngleIndicator||e.showAngleIndicator,showCollisions:void 0!==e.showCollisions&&e.showCollisions,showSleeping:void 0===e.showSleeping||e.showSleeping,showNormals:void 0!==e.showNormals&&e.showNormals,showBounds:void 0!==e.showBounds&&e.showBounds,showPositionImpulses:void 0!==e.showPositionImpulses&&e.showPositionImpulses,showVelocity:void 0!==e.showVelocity&&e.showVelocity,showAngularVelocity:void 0!==e.showAngularVelocity&&e.showAngularVelocity,showBroadphaseGrid:void 0!==e.showBroadphaseGrid&&e.showBroadphaseGrid,showPositions:void 0!==e.showPositions&&e.showPositions,showStatus:void 0!==e.showStatus&&e.showStatus},this.canvas=e.canvas||this.createCanvas(e.width||800,e.height||600),this.ctx=this.canvas.getContext("2d"),this.element=e.element,this.statusTimer=0,this.statusText="",this.element?this.element.appendChild(this.canvas):console.warn("options.element was undefined, canvas was created but not appended"),this.mouse=new ht(this),this.mouse.events.on("mousemove",t=>{this.mouseMove(t)}),this.mouse.events.on("wheel",t=>{this.mouseWheel(t)})}step(t){this.statusTimer+=t.delta,this.events.trigger("beforeStep",[{render:this,timestamp:t}]),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.fillStyle=this.options.backgroundColor,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.ctx.translate(this.canvas.width/2+this.options.translate.x*this.options.scale.x,this.canvas.height/2+this.options.translate.y*this.options.scale.y),this.ctx.scale(this.options.scale.x,this.options.scale.y),this.options.lineWidth=1/Math.pow(this.options.scale.x+this.options.scale.y,.5)*3;const e=this.engine.world.allBodies(),s=this.engine.world.allConstraints();this.options.showBodies&&this.bodies(e),this.options.showConstraints&&this.constraints(s),this.options.showAngleIndicator&&this.angleIndicator(e),this.options.showCollisions&&this.collisions(),this.options.showNormals&&this.normals(e),this.options.showBounds&&this.bounds(e),this.options.showPositionImpulses&&this.positionImpulses(e),this.options.showVelocity&&this.velocity(e),this.options.showAngularVelocity&&this.angularVelocity(e),this.options.showBroadphaseGrid&&this.grid(),this.options.showPositions&&this.positions(e),this.events.trigger("afterStep",[{render:this,timestamp:t}]),this.ctx.setTransform(1,0,0,1,0,0),this.options.showStatus&&this.status()}bodies(t){for(const e of t){const t=e.sleepState!==u.AWAKE&&this.options.showSleeping?"rgb(100, 100, 100)":"rgb(200, 200, 200)";for(const s of e.shapes){const e=s.getWorldPosition();s.type===f.AAB?ct.rect(this.ctx,e,s.width,s.height,0,t,!1,this.options.lineWidth/20):s.type===f.CIRCLE?ct.circle(this.ctx,e,s.radius,t,!1,this.options.lineWidth/20):s.type===f.CONVEX&&ct.polygon(this.ctx,s.getWorldVertices(),t,!1,this.options.lineWidth/20)}}}constraints(t){for(const e of t){const t=e.getWorldPointA(),s=e.getWorldPointB();for(const i of e.equations)if(i.type===ot.DISTANCE_EQUATION)if(e.length<=1||i.stiffness>.8)ct.line(this.ctx,t,s,"rgb(128, 128, 128)",this.options.lineWidth/20);else{const i=r.subtract(s,t,r.temp[0]),o=r.length(i),n=r.rotate90(r.divide(i,o,r.temp[1])),a=Math.max(2*e.length,4);this.ctx.beginPath(),this.ctx.moveTo(t.x,t.y);for(let e=1;e<a;++e){const s=e%2==0?1:-1,o=r.scale(n,.25*s,r.temp[2]),h=e/a;this.ctx.lineTo(t.x+i.x*h+o.x,t.y+i.y*h+o.y)}this.ctx.lineTo(s.x,s.y),this.ctx.strokeStyle="rgb(128, 128, 128)",this.ctx.lineWidth=this.options.lineWidth/20,this.ctx.stroke()}ct.circle(this.ctx,t,this.options.lineWidth/10,"rgb(100, 100, 100)"),ct.circle(this.ctx,s,this.options.lineWidth/10,"rgb(100, 100, 100)")}}angleIndicator(t){for(const e of t)for(const t of e.shapes){const e=t.getWorldPosition(),s=t.getWorldAngle();if(t.type===f.AAB)ct.line(this.ctx,e,r.add(r.set(r.temp[0],t.width/2,0),e),"rgb(200, 200, 200)",this.options.lineWidth/10);else if(t.type===f.CIRCLE)ct.line(this.ctx,e,r.add(r.set(r.temp[0],Math.cos(s)*t.radius,Math.sin(s)*t.radius),e),"rgb(200, 200, 200)",this.options.lineWidth/10);else if(t.type===f.CONVEX){const s=t.getWorldVertices();ct.line(this.ctx,e,r.set(r.temp[0],(s[0].x+s[1].x)/2,(s[0].y+s[1].y)/2),"rgb(200, 200, 200)",this.options.lineWidth/10)}}}collisions(){const t=this.engine.narrowphase.pairs;for(const e of t.values())if(e.isActive)for(const t of e.shapePairs.values())if(t.isActive)for(let e=0;e<t.contactsCount;++e){const s=t.contacts[e];ct.circle(this.ctx,s.vertex,this.options.lineWidth/8,"rgb(200, 80, 80)"),ct.line(this.ctx,s.vertex,r.add(r.scale(t.normal,.2,r.temp[0]),s.vertex),"rgb(200, 80, 80)",this.options.lineWidth/8)}}normals(t){for(const e of t)for(const t of e.shapes)if(t.type===f.CONVEX){const e=t.getWorldPosition(),s=t.getWorldNormals(!0);for(const t of s)ct.line(this.ctx,e,r.add(e,t,r.temp[0]),"rgb(200, 100, 100)",this.options.lineWidth/8)}}bounds(t){for(const e of t){const t=e.getBounds(),s=t.max.x-t.min.x,i=t.max.y-t.min.y;ct.rect(this.ctx,r.set(r.temp[0],t.min.x+s/2,t.min.y+i/2),s,i,0,"rgb(48, 48, 48)",!1,this.options.lineWidth/50)}}positionImpulses(t){for(const e of t)ct.line(this.ctx,e.position,r.add(e.position,e.positionImpulse,r.temp[0]),"rgb(80, 80, 200)",this.options.lineWidth/10)}velocity(t){for(const e of t)ct.line(this.ctx,e.position,r.add(e.position,r.scale(e.velocity,5,r.temp[0]),r.temp[0]),"rgb(80, 200, 80)",this.options.lineWidth/10)}angularVelocity(t){for(const e of t)ct.circle(this.ctx,e.position,5*Math.abs(e.angularVelocity),"rgb(80, 200, 80)",!1,this.options.lineWidth/20)}grid(){const t=this.engine.broadphase,e=t.grid;for(const s of e.keys()){const i=e.get(s);i.size<2||!i.render||(r.add(s,r.set(r.temp[0],.5,.5)),ct.rect(this.ctx,r.scale(s,t.gridSize),t.gridSize,t.gridSize,0,"rgb(80, 200, 80)",!1,this.options.lineWidth/50))}}positions(t){for(const e of t)ct.circle(this.ctx,e.position,this.options.lineWidth/6,"rgb(40, 160, 40)")}status(){if(this.statusTimer>=.1){this.statusTimer-=.1,this.statusText="",this.engine.runner&&(this.statusText+=`fps: ${Math.round(this.engine.runner.fps)}   `,this.statusText+=`tps: ${Math.round(this.engine.runner.tps)}   `);const t=this.engine.world.allBodies();this.statusText+=`bodies: ${t.length}   `;const e=this.engine.world.allConstraints();this.statusText+=`constraints: ${e.length}   `,this.statusText+=`broadphasePairs: ${this.engine.broadphase.activePairsCount}   `,this.statusText+=`midphasePairs: ${this.engine.midphase.activePairsCount}   `,this.statusText+=`narrowphasePairs: ${this.engine.narrowphase.activePairsCount}   `,this.statusText+=`positionIterations: ${this.engine.solver.positionIterations}   `,this.statusText+=`velocityIterations: ${this.engine.solver.velocityIterations}   `,this.statusText+=`constraintIterations: ${this.engine.solver.constraintIterations}   `}this.ctx.font="12px Arial",this.ctx.fillStyle="rgb(128, 128, 128)",this.ctx.fillText(this.statusText,20,20,this.canvas.width-50)}scale(t){r.add(this.options.scale,t)}setScale(t){r.clone(t,this.options.scale)}translate(t){r.add(this.options.translate,t)}setTranslate(t){r.clone(t,this.options.translate)}mouseMove(t){this.mouse.rightButtonPressed&&r.add(this.options.translate,t.movement)}mouseWheel(t){this.options.scale.x-=t.deltaY*this.options.scale.x/2500,this.options.scale.y-=t.deltaY*this.options.scale.y/2500}createCanvas(t,e){const s=document.createElement("canvas");return s.style.position="fixed",s.style.left=0,s.style.top=0,s.style.right=0,s.style.bottom=0,s.width=t,s.height=e,s.oncontextmenu=function(){return!1},s}static createCanvas(t,e){const s=document.createElement("canvas");return s.style.position="fixed",s.style.left=0,s.style.top=0,s.style.right=0,s.style.bottom=0,s.width=t,s.height=e,s.oncontextmenu=function(){return!1},s}},Draw:ct,Runner:class{constructor(t={}){this.setTps(t.tps||60),this.tps=0,this.delta=0,this.deltaAccumulator=0,this.time=performance.now()/1e3,this.events=new i,this.event={time:0,delta:0,tps:0},this.renderEvent={time:0,delta:0,fps:0},this.enabled=!1,this.renderTime=performance.now()/1e3,this.enabledRender=!1}run(){this.enabled||(this.enabled=!0,this.tick())}stop(){this.enabled=!1}tick(){if(!this.enabled)return;const t=performance.now()/1e3;for(this.delta=t-this.time,this.tps=1/this.delta,this.time=t,this.event.time=this.time,this.event.delta=this.delta,this.event.tps=this.tps,this.events.trigger("beforeTick",[this.event]),this.events.trigger("tick",[this.event]),this.deltaAccumulator+=this.delta,this.deltaAccumulator=Math.min(this.deltaAccumulator,5*this.fixedDelta);this.deltaAccumulator>this.fixedDelta;)this.deltaAccumulator-=this.fixedDelta,this.event.time=this.time-this.deltaAccumulator,this.event.delta=this.fixedDelta,this.event.tps=this.fixedTps,this.events.trigger("beforeUpdate",[this.event]),this.events.trigger("update",[this.event]),this.events.trigger("afterUpdate",[this.event]);this.events.trigger("beforeTick",[this.event]),setTimeout(()=>{this.tick()},0)}setTps(t){this.fixedTps=t,this.fixedDelta=1/t}runRender(){this.enabledRender||(this.enabledRender=!0,this.render())}stopRender(){this.enabledRender=!1}render(){if(!this.enabledRender)return;const t=performance.now()/1e3;this.renderDelta=t-this.renderTime,this.fps=1/this.renderDelta,this.renderTime=t,this.renderEvent.time=this.renderTime,this.renderEvent.delta=this.renderDelta,this.renderEvent.fps=this.fps,this.events.trigger("beforeRender",[this.renderEvent]),this.events.trigger("render",[this.renderEvent]),this.events.trigger("afterRender",[this.renderEvent]),window.requestAnimationFrame(()=>{this.render()})}}}}]);